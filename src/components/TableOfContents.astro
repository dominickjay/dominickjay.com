---
import type { MarkdownHeading } from 'astro';

type Props = {
  headings: MarkdownHeading[];
};

type HeadingWithSubheadings = MarkdownHeading & {
  subheadings: MarkdownHeading[];
};

const { headings } = Astro.props;

const grouppedHeadings = headings.reduce((array, heading) => {
  if (heading.depth === 2) {
    array.push({ ...heading, subheadings: [] });
  } else if (heading.depth === 3) {
    array.at(-1)?.subheadings.push(heading);
  }

  return array;
}, [] as HeadingWithSubheadings[]);
---

<nav class="toc" id="table-of-contents" aria-label="Table Of Contents">
    <span>Contents: </span>
    <ol class="pl-[16px] mt-[8px]">
        {
        grouppedHeadings.map((h) => (
            <li>
                <a class="opacity-[0.84] mt-[2px] block" href={`#${h.slug}`}>{h.text}</a>
                {h.subheadings.length > 0 && (
                    <ol>
                    {h.subheadings.map((sub) => (
                        <li>
                            <a class="opacity-[0.84] mt-[2px] block" href={`#${sub.slug}`}>{sub.text}</a>
                        </li>
                    ))}
                    </ol>
                )}
            </li>
        ))
        }
    </ol>
</nav>

<!-- <script is:inline>
  // This script tag is useful only if you want to display the TOC alongside the blog post...
  // ... and highlight the section that the user is currently reading through.
  // Feel free to remove this tag if you don't need this type of functionality.

  const observer = new IntersectionObserver(
    (entries) => {
      for (const entry of entries) {
        const headingFragment = `#${entry.target.id}`;
        console.log(headingFragment);
        const tocItem = document.querySelector(`a[href="${headingFragment}"]`);

        if (entry.isIntersecting) {
          const previouslyActivatedItem =
            document.querySelector('.active-toc-item');

          previouslyActivatedItem?.classList.remove('active-toc-item');
          tocItem.classList.add('active-toc-item');
        } else {
          const isAnyOtherEntryIntersecting = entries.some(
            (e) => e.target.id !== entry.target.id && e.isIntersecting
          );

          if (isAnyOtherEntryIntersecting) {
            tocItem.classList.remove('active-toc-item');
          }
        }
      }
    },
    { root: null, rootMargin: '0px', threshold: [1] }
  );

  const sectionHeadings = document.querySelectorAll(
    'h2'
  );

  for (const heading of sectionHeadings) {
    console.log(heading);
    observer.observe(heading);
  }
</script> -->

<script is:inline>
    const observer = new IntersectionObserver(
      (entries) => {
        entries.forEach((entry) => {
          const headingFragment = `#${entry.target.id}`;
          const tocItem = document.querySelector(`a[href="${headingFragment}"]`);

          if (!tocItem) return;

          if (entry.isIntersecting) {
            // Remove active class from any previously active items
            document.querySelectorAll('.active-toc-item')
              .forEach(item => item.classList.remove('active-toc-item'));

            // Add active class to current item
            tocItem.classList.add('active-toc-item');
          }
        });
      },
      {
        root: null,
        rootMargin: '-20% 0px -20% 0px', // Adds some margin to when the heading is considered "visible"
        threshold: 0.5 // Trigger when heading is 50% visible
      }
    );

    // Wait for DOM to be ready
    document.addEventListener('DOMContentLoaded', () => {
      // Get all h2 headings
      const headings = document.querySelectorAll('h2');

      // Observe each heading
      headings.forEach(heading => {
        if (heading.id) {  // Only observe headings with IDs
          observer.observe(heading);
        }
      });
    });
  </script>

<style>
    .active-toc-item {
        text-decoration: underline;
        text-decoration-style: wavy;
    }
</style>
