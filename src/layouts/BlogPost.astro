---
import type { CollectionEntry } from "astro:content";
import { Temporal } from "@js-temporal/polyfill";
import BaseHead from "../components/BaseHead.astro";
import Header from "../components/Header.astro";
import Footer from "../components/Footer.astro";
import PatternBanner from "../components/Pattern-Banner.astro";
import FormattedDate from "../components/FormattedDate.astro";
import { generateCategoryData } from "../utils/utils.mjs";
import TableOfContents from "../components/TableOfContents.astro";
import DefaultHero from "../components/DefaultHero.astro";
import Tags from "../components/Tags.astro";

type Props = CollectionEntry<"writing">["data"] & {
	headings?: any[];
	timeToRead?: number;
};

const { title, description, pubDate, updatedDate, tags, growth } = Astro.props;
---

<html lang="en">
	<head>
		<BaseHead title={title} description={description} />
	</head>

	<body>
		<Header />
		<main>
			<article>
				<DefaultHero title={title} description={description} growth={growth} />
				<PatternBanner />
				<div
					class="main-container post-container container prose grid grid-rows-auto pt-[32px] md:pt-[64px] gap-[43px] [--grid-placement:1] [--gutter:16px] md:[--grid-placement:12] md:[--gutter:43px]"
					style=""
				>
					<!-- <div
						class="hidden md:flex pin-rail col-start-1 col-span-full md:col-span-4 flow"
						aria-hidden="true"
						id=""
					>
						<div id="pin-container" class="pin-container"></div>
					</div> -->

					<div
						class="content-flow content col-span-full grid grid-rows-auto md:[--grid-placement:12] !gap-y-0 overflow-clip flow prose"
						style="--flow-space: var(--space-m)"
					>
						<slot />
					</div>
				</div>
			</article>
		</main>
		<PatternBanner fill="rgba(0, 0, 0, 0.64)" />
	</body><script
		data-goatcounter="https://dominickjay.goatcounter.com/count"
		async
		src="//gc.zgo.at/count.js"></script>
</html>

<script is:inline>
	function updateTimeTheme() {
		const now = Temporal.Now.zonedDateTimeISO();
		const hour = now.hour;
		let period = "";

		if (hour >= 5 && hour < 9) period = "early-morning";
		else if (hour >= 9 && hour < 12) period = "late-morning";
		else if (hour >= 12 && hour < 15) period = "early-afternoon";
		else if (hour >= 15 && hour < 17) period = "mid-afternoon";
		else if (hour >= 17 && hour < 19) period = "last-afternoon";
		else if (hour >= 19 && hour < 22) period = "evening";
		else period = "night";

		document.documentElement.setAttribute("data-time", period);
	}

	updateTimeTheme();
</script>

<!-- <script is:inline>
	document.addEventListener("DOMContentLoaded", () => {
		const contentFlow = document.querySelector(".content-flow");
		const pinContainer = document.getElementById("pin-container");

		// --- 1. PREPARATION: Add the required CSS class dynamically ---
		// This handles content generated via Markdown or other dynamic means.
		if (contentFlow) {
			const potentialTargets = contentFlow.querySelectorAll(
				"aside, pre, .blockquote-container",
			);
			potentialTargets.forEach((element, index) => {
				// Apply the class that hides the original element and identifies it for cloning
				element.classList.add("embedded-pin-target");
				element.id = `pin-target-${index}`;

				// Find the nearest visible element that precedes this target.
				// Skip non-visual nodes (e.g., STYLE/SCRIPT) or zero-height elements.
				let precedingElement = element.previousElementSibling;
				while (
					precedingElement &&
					(precedingElement.tagName === "STYLE" ||
						precedingElement.tagName === "SCRIPT" ||
						precedingElement.getBoundingClientRect().height === 0)
				) {
					precedingElement = precedingElement.previousElementSibling;
				}

				// Use the found preceding element, or fall back to the target itself
				const triggerElement = precedingElement || element;
				triggerElement.setAttribute("data-target-pin", element.id);
			});
		}

		// --- ðŸš¨ DEBUG CHECK 1: Ensure containers exist ---
		if (!pinContainer) {
			return;
		}

		// Now we query the targets using the class we just added
		const embeddedTargets = document.querySelectorAll(".embedded-pin-target");
		const triggerElements = document.querySelectorAll("[data-target-pin]");

		if (embeddedTargets.length === 0) {
			pinContainer.parentElement.remove();
			contentFlow.classList.add("col-span-full");
			contentFlow.classList.remove("col-span-8");
			contentFlow.classList.remove("md:col-start-5");
			contentFlow.classList.remove("md:col-span-8");
			contentFlow.classList.remove("md:col-start-5");
			return;
		}

		const targetMap = new Map();
		let lastPinnedId = null;

		// 2. CLONING AND MAPPING STEP

		embeddedTargets.forEach((originalTarget) => {
			const originalId = originalTarget.id;

			if (!originalId) {
				return;
			}

			try {
				const clone = originalTarget.cloneNode(true);

				clone.id = `cloned-${originalId}`;
				clone.classList.add("cloned-pin");

				pinContainer.appendChild(clone);
				targetMap.set(originalId, clone);
			} catch (error) {
				console.error(`ERROR during cloning for ID ${originalId}:`, error);
			}
		});

		// 3. OBSERVER SETUP AND LOGIC
		if (targetMap.size === 0) {
			console.error(
				"DEBUG ERROR: Target map is empty. Cloning failed or no IDs found.",
			);
			return;
		}

		const options = {
			// Creates a thin horizontal line at 20% from the top of the viewport
			rootMargin: "-50% 0px -49.9% 0px",
			threshold: 0,
		};

		const deactivateAllPins = () => {
			pinContainer.querySelectorAll(".cloned-pin").forEach((pin) => {
				pin.classList.remove("active-pin");
			});
		};

		const observerCallback = (entries) => {
			let currentIntersectingId = null;

			// Iterate backward (last one wins)
			for (let i = entries.length - 1; i >= 0; i--) {
				const entry = entries[i];

				if (entry.isIntersecting) {
					// Get the ID of the content to pin from the heading's attribute (e.g., "aside-1")
					const pinId = entry.target.getAttribute("data-target-pin");

					if (pinId && targetMap.has(pinId)) {
						currentIntersectingId = pinId;
						break;
					}
				}
			}

			// --- State Management: Handle transitions (gaps) ---
			deactivateAllPins();

			let pinToActivateId = null;

			if (currentIntersectingId) {
				pinToActivateId = currentIntersectingId;
				lastPinnedId = currentIntersectingId; // Update cache
			} else if (lastPinnedId && targetMap.has(lastPinnedId)) {
				// If in a gap, use the last successfully pinned content
				pinToActivateId = lastPinnedId;
			}

			// Apply the state change
			if (pinToActivateId) {
				const targetPinClone = targetMap.get(pinToActivateId);
				if (targetPinClone) {
					targetPinClone.classList.add("active-pin");
				}
			}
		};

		const observer = new IntersectionObserver(observerCallback, options);

		triggerElements.forEach((trigger) => {
			observer.observe(trigger);
		});

		// Initial check to pin the content for the first section
		observerCallback(observer.takeRecords());
	});
</script> -->

<style is:inline>
	#progress {
		/*position: fixed;*/
		left: 0;
		top: 0;
		width: 100%;
		height: 64px;

		transform-origin: 0 50%;
		animation: grow-progress auto linear;
		animation-timeline: --page-scroll;
	}

	#progress > *:first-child {
		position: relative;
		transform: translateY(-50%);
	}

	.content-flow > * {
		grid-column: 1 / span 1;
	}

	@media (width >= 760px) {
		.content-flow > * {
			grid-column: 5 / span 8;
		}

		.content-flow > .post-recommendations {
			grid-column: 1 / span 4;
			grid-row: 1 / span 999;
		}

		/*.content-flow > :is(pre, code, aside) {
			grid-column: 1 / span 4;
			grid-row: auto;
		}*/
	}

	@media (width >= 1024px) {
		.embedded-pin-target {
			opacity: 0;
			height: 0;
			margin: 0;
			padding: 0;
			overflow: hidden;
			transition: opacity 0.3s;
			display: none;
		}

		/* 2. PIN RAIL (The Fixed Sidebar) */
		.pin-rail {
			overflow: hidden;
			position: sticky;
			top: 0;
			left: 0;
			/* Offset to the right of the content flow */
			margin-right: -480px;
			width: 100%;
			height: 100vh;
			padding: 50px 20px;
			box-sizing: border-box;
			z-index: 1;
		}

		/* 3. PIN CONTAINER: Where the visible content is placed */
		.pin-container {
			position: relative;
			height: 90vh;
			width: 100%;
		}

		/* 4. BASE STYLES for the CLONED Pinned Content */
		.pin-container > .cloned-pin {
			position: absolute;
			top: 50%;
			/* transform: scale(0.95); */

			width: 100%;
			height: auto;
			box-sizing: border-box;

			/* CRITICAL: Default state is invisible */
			opacity: 0;
			visibility: hidden;
			transition:
				opacity 0.4s,
				transform 0.4s,
				visibility 0.4s;
		}

		/* 5. ACTIVE STATE: Applied by JS */
		.pin-container > .cloned-pin.active-pin {
			opacity: 1;
			visibility: visible;
			transform: translateY(-50%) scale(1);
			z-index: 10;
		}

		.cloned-pin blockquote {
			font-size: 1.25rem;
			line-height: 1.5;
			font-style: italic;
			font-weight: 400;
			padding-inline-start: 0;
			border-left: none;
		}

		pre.cloned-pin {
			padding: var(--space-s);
		}

		.cloned-pin {
			display: flex;
			flex-direction: column;
			gap: var(--space-m);
		}
	}
</style>
