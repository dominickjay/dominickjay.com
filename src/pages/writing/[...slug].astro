---
import { type CollectionEntry, getCollection } from 'astro:content';
import BlogPost from '../../layouts/BlogPost.astro';
import { render } from 'astro:content';
import { getReadingTime } from '../../utils/utils.mjs';
import MusicGrid from '../../components/MusicGrid.astro';
import RaindropGrid from '../../components/RaindropGrid.astro';
import { getRaindropBookmarks } from '../../lib/raindrop';
import { getWeeklyAlbumChart, enrichAlbumsWithImages } from '../../lib/lastfm';

const baseUrl = import.meta.env.DEV
  ? "http://localhost:4321"
  : new URL(Astro.request.url).origin;
const { slug } = Astro.params;
const posts = await getCollection('writing');
const post = posts.find((p) => p.id === slug);
const ogImage = new URL(`/open-graph/${slug}.png`, baseUrl).toString();

if (!post) {
    return Astro.redirect('/404');
}

const { Content, headings } = await render(post);
const timeToRead = getReadingTime(post.body);

// import BlogPostPreviewLite from "./BlogPostPreviewLite.astro";

const { tags } = post.data;

const excludedTags = ["update", "blog", "writing", "tutorial", "news", "announcement"];
const finalTags = tags.filter((tag) => !excludedTags.includes(tag));

const allPosts1 = posts
  .filter(
    (post: CollectionEntry<"writing">) => {
      // Exclude the current article
      if (post.slug === slug) return false;

      // Only include posts that have matching tags
      return post.data.tags?.filter((tag) => finalTags.includes(tag)).length > 0;
    }
  )
  .map((post: CollectionEntry<"writing">) => ({
    ...post,
    sameTagCount: post.data.tags.filter((tag) => finalTags.includes(tag)).length,
  }))
  .sort((a, b) => {
    if (a.sameTagCount > b.sameTagCount) return -1;
    if (b.sameTagCount > a.sameTagCount) return 1;

    if (a.data.date > b.data.date) return -1;
    if (a.data.date < b.data.date) return 1;

    return 0;
  })
  .slice(0, 2);

// Fetch music data in the frontmatter
let musicData = null;
try {
    const { musicDateFrom, musicDateTo } = post.data;
    const lastFmApiKey = import.meta.env.LAST_FM_API_KEY;

    if (musicDateFrom && musicDateTo && lastFmApiKey) {
        const data = await getWeeklyAlbumChart(musicDateFrom, musicDateTo, lastFmApiKey);
        if (!data.error) {
            // Enrich albums with images
            if (data.weeklyalbumchart?.album) {
                data.weeklyalbumchart.album = await enrichAlbumsWithImages(data.weeklyalbumchart.album, lastFmApiKey);
            }
            musicData = data;
            console.log('Processed music data:', musicData);
        } else {
            console.error('Last.fm API error:', data.message);
        }
    } else {
        console.log('Missing required data:', {
            hasMusicDateFrom: !!musicDateFrom,
            hasMusicDateTo: !!musicDateTo,
            hasApiKey: !!lastFmApiKey
        });
    }
} catch (error) {
    console.error('Error fetching music data:', error);
}

// Fetch Raindrop bookmarks
let raindropData = null;
try {
    const raindropApiKey = import.meta.env.RAINDROP_API_KEY;
    const raindropBookmarks = import.meta.env.RAINDROP_BOOKMARKS;
    const { linksFrom, linksTo } = post.data;

    if (raindropApiKey && linksFrom && linksTo) {
        raindropData = await getRaindropBookmarks(raindropBookmarks, raindropApiKey, linksFrom, linksTo);
        console.log('Raindrop data:', raindropData);
    } else {
        console.error('Missing required data:', {
            hasApiKey: !!raindropApiKey,
            hasLinksFrom: !!linksFrom,
            hasLinksTo: !!linksTo
        });
    }
} catch (error) {
    console.error('Error fetching Raindrop data:', error);
}

console.log('Final musicData being passed to BlogPost:', musicData);

export async function getStaticPaths() {
	const posts = await getCollection('writing');
	return posts.map((post) => ({
		params: { slug: post.id },
		props: { post }
	}));
}

---
<head>
    <meta charset="utf-8" />
    <meta property="og:image" content={ogImage} />
    <meta property="twitter:image" content={ogImage} />
</head>

<BlogPost {...post.data} headings={headings} timeToRead={timeToRead} musicData={musicData} raindropData={raindropData}>
    <Content />
    {musicData && (
    <MusicGrid musicData={musicData} />
    )}
    {raindropData && (
        <RaindropGrid raindropData={raindropData} />
    )}
     <div class="prose mt-5 p-5 flex flex-col gap-y-[32px]">
         <h2 class="">You might also like...</h2>
         <div class="flex gap-[16px] w-full">
            {allPosts1.map((post) => (
                <div key={post.id} class="border p-4 md:max-w-1/2">
                    <a href={`/writing/${post.id}`} class="flex flex-col gap-y-[8px]">
                        <span class="h3">{post.data.title}</span>
                        <div class="">{post.data.description}</div>
                    </a>
                </div>
            ))}
         </div>
     </div>
</BlogPost>
