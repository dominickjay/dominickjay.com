---
import BaseHead from "../components/BaseHead.astro";
import Header from "../components/Header.astro";
import PatternBanner from "../components/Pattern-Banner.astro";
import BookItem from "../components/BookItem.astro";
import Footer from "../components/Footer.astro";
import { Image } from "astro:assets";
import { SITE_TITLE, SITE_DESCRIPTION, SITE_TAGLINE } from "../consts";
import moment from "moment";

let currentBooks: any[] = [];
let finishedBooks: any[] = [];
let readBooks: any[] = [];
let toReadBooks: any[] = [];

// Fetch shelf book IDs first to filter them out
let shelfBookIds = new Set();
try {
	const shelfResponse = await fetch("https://literal.club/graphql/", {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({
			query: `query getShelfBySlug($shelfSlug: String!) {
				shelf(where: { slug: $shelfSlug }) {
					books {
						id
					}
				}
			}`,
			variables: {
				shelfSlug: "2026-vg7vfq1",
			},
		}),
	});

	if (shelfResponse.ok) {
		const shelfData = await shelfResponse.json();
		const shelfBooks = shelfData.data?.shelf?.books || [];
		shelfBookIds = new Set(shelfBooks.map((book: any) => book.id));
	}
} catch (error) {
	console.error("Error fetching shelf for filtering:", error);
}

try {
	const response = await fetch("https://literal.club/graphql/", {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({
			query: `query booksByReadingStateAndProfile(
					$limit: Int!
					$offset: Int!
					$readingStatus: ReadingStatus!
					$profileId: String!
				) {
					booksByReadingStateAndProfile(
							limit: $limit
							offset: $offset
							readingStatus: $readingStatus
							profileId: $profileId
					)
					{ id title cover authors {
							name
					} } }`,
			variables: {
				limit: 100,
				offset: 0,
				readingStatus: "WANTS_TO_READ",
				profileId: import.meta.env.profileId,
			},
		}),
	});

	if (!response.ok) {
		throw new Error(`HTTP error! status: ${response.status}`);
	}

	const data = await response.json();
	const allToReadBooks = data.data?.booksByReadingStateAndProfile || [];
	toReadBooks = allToReadBooks.filter(
		(book: any) => !shelfBookIds.has(book.id),
	);
} catch (error) {
	console.error("Error fetching to-read books from Literal.club:", error);
	toReadBooks = [];
}

try {
	const response = await fetch("https://literal.club/graphql/", {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({
			query: `query booksByReadingStateAndProfile(
					$limit: Int!
					$offset: Int!
					$readingStatus: ReadingStatus!
					$profileId: String!
				) {
					booksByReadingStateAndProfile(
							limit: $limit
							offset: $offset
							readingStatus: $readingStatus
							profileId: $profileId
					)
					{ id title cover authors {
							name
					} } }`,
			variables: {
				limit: 100,
				offset: 0,
				readingStatus: "IS_READING",
				profileId: import.meta.env.profileId,
			},
		}),
	});

	if (!response.ok) {
		throw new Error(`HTTP error! status: ${response.status}`);
	}

	const data = await response.json();
	currentBooks = data.data?.booksByReadingStateAndProfile || [];
} catch (error) {
	console.error(
		"Error fetching currently reading books from Literal.club:",
		error,
	);
	currentBooks = [];
}

async function getShelf() {
	try {
		const response = await fetch("https://literal.club/graphql/", {
			method: "POST",
			body: JSON.stringify({
				query: `query getShelfBySlug($shelfSlug: String!) {
					shelf(where: { slug: $shelfSlug }) {
						id
						slug
						title
						description
						profileId
						owner {
							id
							handle
							name
							bio
							image
							invitedByProfileId
						}
						books {
							id
							slug
							title
							subtitle
							description
							isbn10
							isbn13
							language
							pageCount
							publishedDate
							publisher
							cover
							authors {
								id
								name
							}
							gradientColors
						}
					}
				}`,
				variables: {
					shelfSlug: "2026-vg7vfq1",
				},
			}),
			headers: {
				"Content-Type": "application/json",
				authorization: import.meta.env.literalToken ?? "",
			},
		});

		if (!response.ok) {
			throw new Error(`HTTP error! status: ${response.status}`);
		}

		const data = (await response.json()) as any;
		const shelf = data.data?.shelf;
		const booksWithDetails = [];

		for (const book of shelf?.books || []) {
			try {
				const datesResponse = await fetch("https://literal.club/graphql/", {
					method: "POST",
					body: JSON.stringify({
						query: `query getReadDates($bookId: String!, $profileId: String!) {
							getReadDates(bookId: $bookId, profileId: $profileId) {
								started
								finished
							}
						}`,
						variables: {
							bookId: book.id,
							profileId: import.meta.env.profileId,
						},
					}),
					headers: {
						"Content-Type": "application/json",
						authorization: import.meta.env.literalToken ?? "",
					},
				});

				if (!datesResponse.ok) {
					throw new Error(`HTTP error! status: ${datesResponse.status}`);
				}

				const dates = (await datesResponse.json()) as any;
				const date = dates?.data?.getReadDates?.pop();

				// Fetch rating from reviews
				let rating = null;
				try {
					const reviewResponse = await fetch("https://literal.club/graphql/", {
						method: "POST",
						body: JSON.stringify({
							query: `query getReview($bookId: String!, $profileId: String!) {
								review(bookId: $bookId, profileId: $profileId) {
									rating
								}
							}`,
							variables: {
								bookId: book.id,
								profileId: import.meta.env.profileId,
							},
						}),
						headers: {
							"Content-Type": "application/json",
							authorization: import.meta.env.literalToken ?? "",
						},
					});

					if (reviewResponse.ok) {
						const reviewData = (await reviewResponse.json()) as any;
						rating = reviewData?.data?.review?.rating ?? null;
					}
				} catch (error) {
					console.error(`Error fetching review for book ${book.id}:`, error);
				}

				// Determine reading status
				const isCurrentlyReading = currentBooks.some(
					(currentBook: any) => currentBook.id === book.id,
				);
				const hasStarted = date?.started && date?.started !== "unknown";
				const hasFinished = date?.finished && date?.finished !== "unknown";
				const status =
					isCurrentlyReading || (hasStarted && !hasFinished)
						? "IS_READING"
						: hasFinished
							? "FINISHED"
							: "WANTS_TO_READ";

				const bookWithDetails = {
					...book,
					started: date?.started ? date?.started : "unknown",
					finished: date?.finished ? date?.finished : "unknown",
					rating: rating,
					status: status,
				};

				booksWithDetails.push(bookWithDetails);
			} catch (error) {
				console.error(`Error fetching read dates for book ${book.id}:`, error);
				const isCurrentlyReading = currentBooks.some(
					(currentBook: any) => currentBook.id === book.id,
				);
				const bookWithDetails = {
					...book,
					started: "unknown",
					finished: "unknown",
					rating: null,
					status: isCurrentlyReading ? "IS_READING" : "WANTS_TO_READ",
				};
				booksWithDetails.push(bookWithDetails);
			}
		}

		const shelfWithBooks = {
			...shelf,
			books: booksWithDetails,
		};

		console.log(shelfWithBooks);

		return booksWithDetails;
	} catch (error) {
		console.error("Error fetching shelf from Literal.club:", error);
		return [];
	}
}

async function getBooks() {
	try {
		const response = await fetch("https://literal.club/graphql/", {
			method: "POST",
			body: JSON.stringify({
				query: `query booksByReadingStateAndProfile(
				$limit: Int!
				$offset: Int!
				$readingStatus: ReadingStatus!
				$profileId: String!
			) {
				booksByReadingStateAndProfile(
						limit: $limit offset: $offset readingStatus: $readingStatus profileId: $profileId) {
						id title cover authors { name } } }`,
				variables: {
					limit: 100,
					offset: 0,
					readingStatus: "FINISHED",
					profileId: import.meta.env.profileId,
				},
			}),
			headers: {
				"Content-Type": "application/json",
				authorization: import.meta.env.literalToken ?? "",
			},
		});

		if (!response.ok) {
			throw new Error(`HTTP error! status: ${response.status}`);
		}

		const data = (await response.json()) as any;
		const books = new Map<number, any>();

		for (const book of data.data?.booksByReadingStateAndProfile || []) {
			try {
				const datesResponse = await fetch("https://literal.club/graphql/", {
					method: "POST",
					body: JSON.stringify({
						query: `query getReadDates($bookId: String!, $profileId: String!) {
							getReadDates(bookId: $bookId, profileId: $profileId) {
								started
								finished
							}
						}`,
						variables: {
							bookId: book.id,
							profileId: import.meta.env.profileId,
						},
					}),
					headers: {
						"Content-Type": "application/json",
						authorization: import.meta.env.literalToken ?? "",
					},
				});

				if (!datesResponse.ok) {
					throw new Error(`HTTP error! status: ${datesResponse.status}`);
				}

				const dates = (await datesResponse.json()) as any;
				const date = dates?.data?.getReadDates?.pop();

				// Fetch rating from reviews
				let rating = null;
				try {
					const reviewResponse = await fetch("https://literal.club/graphql/", {
						method: "POST",
						body: JSON.stringify({
							query: `query getReview($bookId: String!, $profileId: String!) {
								review(bookId: $bookId, profileId: $profileId) {
									rating
								}
							}`,
							variables: {
								bookId: book.id,
								profileId: import.meta.env.profileId,
							},
						}),
						headers: {
							"Content-Type": "application/json",
							authorization: import.meta.env.literalToken ?? "",
						},
					});

					if (reviewResponse.ok) {
						const reviewData = (await reviewResponse.json()) as any;
						rating = reviewData?.data?.review?.rating ?? null;
					}
				} catch (error) {
					console.error(`Error fetching review for book ${book.id}:`, error);
				}

				const b = {
					...book,
					started: date?.started ? date?.started : "unknown",
					finished: date?.finished ? date?.finished : "unknown",
					rating: rating,
				};

				// Include all books regardless of dates
				if (b.finished != null && b.finished !== "unknown") {
					const year = moment(b.finished).year();

					let read = books.get(year);
					if (read == null) {
						read = [b];
						books.set(year, read);
					} else {
						read.push(b);
					}
				} else {
					// For books without finished dates, use a special year (e.g., 0 or current year)
					const year = 2023; // or new Date().getFullYear() if you prefer current year
					let read = books.get(year);
					if (read == null) {
						read = [b];
						books.set(year, read);
					} else {
						read.push(b);
					}
				}
			} catch (error) {
				console.error(`Error fetching read dates for book ${book.id}:`, error);
				// Continue processing other books even if one fails
				const b = {
					...book,
					started: "unknown",
					finished: "unknown",
					rating: null,
				};
				const year = 2023;
				let read = books.get(year);
				if (read == null) {
					read = [b];
					books.set(year, read);
				} else {
					read.push(b);
				}
			}
		}

		return books;
	} catch (error) {
		console.error("Error fetching finished books from Literal.club:", error);
		return new Map<number, any>();
	}
}

const shelf = await getShelf();
const books = await getBooks();
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
	</head>
	<body>
		<Header />
		<main>
			<div
				class="container flex flex-col md:flex-row gap-[32px] md:gap-[64px] py-[32px] md:py-[64px] md:!max-w-[992px]"
				style="--grid-placement: 12; --gutter: 43px;"
				x-data="{
					list: true,
					floatingCover: {
						show: false,
						x: 0,
						y: 0,
						src: '',
						title: ''
					}
				}"
			>
				<div
					class="flex flex-col gap-[32px] w-full relative"
					@mousemove="floatingCover.x = $event.clientX + 20; floatingCover.y = $event.clientY + 20"
					@mouseleave="floatingCover.show = false; floatingCover.src = ''; floatingCover.title = ''; console.log('floating cover is', typeof(floatingCover.src))"
				>
					<!-- Floating book cover -->
					<div
						x-show="floatingCover.show && floatingCover.src"
						x-transition.opacity
						class="fixed pointer-events-none z-50 w-[200px] aspect-[1/1.5] overflow-hidden shadow-lg"
						:class="{ 'opacity-100': floatingCover.show && floatingCover.src, 'opacity-0': !floatingCover.show || !floatingCover.src }"
						x-bind:style="`left: ${floatingCover.x}px; top: ${floatingCover.y}px;`"
					>
						<div x-show="floatingCover.src" class="relative w-full h-full">
							<img
								x-bind:src="floatingCover.src"
								x-bind:alt="floatingCover.title"
								class="w-full h-full object-cover"
							/>
						</div>
					</div>

					<div class="flex flex-col gap-[20px]">
						<h2 class="h2 col-span-full mb-[24px]">2026 Reading List</h2>
						<ol
							class="post-list flow max-md:mx-[-16px]"
							style="--flow-space: 0;"
						>
							{
								shelf?.map((book: any, i: number) => (
									<BookItem
										title={book.title}
										author={book.authors[0]["name"]}
										rating={book.rating}
										cover={book.cover}
										started={book.started}
										finished={book.finished}
										status={book.status}
										showStrikethrough=true
									/>
								))
							}
						</ol>
					</div>

					{
						[...books].map((year, i) => (
							<ul class="col-span-full">
								<li>
									{i === 0 ? (
										<div class="flex flex-col mt-[var(--space-xs)]">
											<h2 class="h2">
												Books read in {year[0]}{" "}
												<span class="text-[20px] opacity-75">
													({year[1].length})
												</span>
											</h2>
											<ol
												class="post-list flow max-md:mx-[-16px] gap-y-[var(--space-m)] mt-[var(--space-m)]"
												style="--flow-space: 0;"
											>
												{[...books][i][1].map((book: any) => (
													<BookItem
														title={book.title}
														author={book.authors[0]["name"]}
														rating={book.rating}
														cover={book.cover}
													/>
												))}
											</ol>
										</div>
									) : (
										<details class="flex flex-col">
											<summary class="h2 cursor-pointer list-none">
												<span>
													Books read in {year[0]}{" "}
													<span class="text-[20px] opacity-75">
														({year[1].length})
													</span>
												</span>
											</summary>
											<ol
												class="post-list flow max-md:mx-[-16px] mt-[var(--space-m)]"
												style="--flow-space: 0;"
											>
												{[...books][i][1].map((book: any, index: number) => (
													<BookItem
														key={index}
														title={book.title}
														author={book.authors[0]["name"]}
														rating={book.rating}
														cover={book.cover}
													/>
												))}
											</ol>
										</details>
									)}
								</li>
							</ul>
						))
					}
					<ul class="col-span-full">
						<li>
							<div
								class="flex flex-col gap-y-[var(--space-s)] md:gap-y-[var(--space-m)]"
							>
								<h2 class="h2">
									Backlog{" "}
								</h2>
								<ol
									class="post-list flow max-md:mx-[-16px]"
									style="--flow-space: 0;"
								>
									{
										toReadBooks.map((book) => (
											<BookItem
												title={book.title}
												author={book.authors[0]["name"]}
											/>
										))
									}
								</ol>
							</div>
						</li>
					</ul>
				</div>
			</div>
		</main>

		<PatternBanner fill="rgba(0, 0, 0, 0.64)" />
	</body>
</html>
