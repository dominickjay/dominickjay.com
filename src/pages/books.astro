---
// Astro.response.headers.set("Cache-Control", "p currently ublic, max-age=300, s-maxage=86400");
import BaseHead from "../components/BaseHead.astro";
import Header from "../components/Header.astro";
import PatternBanner from "../components/Pattern-Banner.astro";
import BookItem from "../components/BookItem.astro";
import { SITE_TITLE, SITE_DESCRIPTION } from "../consts";
import moment from "moment";
import { fetchWithCache } from "./api/cache.js";

const profileId = import.meta.env.profileId;
const literalToken = import.meta.env.literalToken ?? "";

// Helper function to make GraphQL requests
async function literalGraphQL(
  query: string,
  variables: any,
  useAuth = false
) {
  const response = await fetch("https://literal.club/graphql/", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      ...(useAuth && { authorization: literalToken }),
    },
    body: JSON.stringify({ query, variables }),
  });

  if (!response.ok) {
    throw new Error(`HTTP error! status: ${response.status}`);
  }

  return response.json();
}

// Fetch shelf book IDs first to filter them out
let shelfBookIds = new Set();
try {
  const shelfData = await fetchWithCache(
    `shelf-ids-2026-vg7vfq1`,
    () =>
      literalGraphQL(
        `query getShelfBySlug($shelfSlug: String!) {
          shelf(where: { slug: $shelfSlug }) {
            books {
              id
            }
          }
        }`,
        { shelfSlug: "2026-vg7vfq1" }
      )
  );

  const shelfBooks = shelfData.data?.shelf?.books || [];
  shelfBookIds = new Set(shelfBooks.map((book: any) => book.id));
} catch (error) {
  console.error("Error fetching shelf for filtering:", error);
}

// Fetch to-read and currently reading books in parallel
let currentBooks: any[] = [];
let toReadBooks: any[] = [];

try {
  const [toReadData, currentData] = await Promise.all([
    fetchWithCache(
      `books-wants-to-read-${profileId}`,
      () =>
        literalGraphQL(
          `query booksByReadingStateAndProfile(
            $limit: Int!
            $offset: Int!
            $readingStatus: ReadingStatus!
            $profileId: String!
          ) {
            booksByReadingStateAndProfile(
              limit: $limit
              offset: $offset
              readingStatus: $readingStatus
              profileId: $profileId
            ) {
              id
              title
              cover
              authors {
                name
              }
            }
          }`,
          {
            limit: 100,
            offset: 0,
            readingStatus: "WANTS_TO_READ",
            profileId,
          }
        )
    ),
    literalGraphQL(
      `query booksByReadingStateAndProfile(
        $limit: Int!
        $offset: Int!
        $readingStatus: ReadingStatus!
        $profileId: String!
      ) {
        booksByReadingStateAndProfile(
          limit: $limit
          offset: $offset
          readingStatus: $readingStatus
          profileId: $profileId
        ) {
          id
          title
          cover
          authors {
            name
          }
        }
      }`,
      {
        limit: 100,
        offset: 0,
        readingStatus: "IS_READING",
        profileId,
      }
    ),
  ]);

  const allToReadBooks = toReadData.data?.booksByReadingStateAndProfile || [];
  toReadBooks = allToReadBooks.filter(
    (book: any) => !shelfBookIds.has(book.id)
  );

  currentBooks = currentData.data?.booksByReadingStateAndProfile || [];
} catch (error) {
  console.error("Error fetching books:", error);
  toReadBooks = [];
  currentBooks = [];
}

// Helper to fetch book details (dates and rating) in parallel
async function fetchBookDetails(bookId: string) {
  const [datesData, reviewData] = await Promise.all([
    fetchWithCache(
      `book-dates-${bookId}-${profileId}`,
      () =>
        literalGraphQL(
          `query getReadDates($bookId: String!, $profileId: String!) {
            getReadDates(bookId: $bookId, profileId: $profileId) {
              started
              finished
            }
          }`,
          { bookId, profileId },
          true
        )
    ),
    fetchWithCache(
      `book-review-${bookId}-${profileId}`,
      async () => {
        try {
          return await literalGraphQL(
            `query getReview($bookId: String!, $profileId: String!) {
              review(bookId: $bookId, profileId: $profileId) {
                rating
              }
            }`,
            { bookId, profileId },
            true
          );
        } catch {
          return { data: { review: { rating: null } } };
        }
      }
    ),
  ]);

  const dates = datesData?.data?.getReadDates || [];
  const date = dates.pop();
  const rating = reviewData?.data?.review?.rating ?? null;

  return {
    started: date?.started || "unknown",
    finished: date?.finished || "unknown",
    rating,
  };
}

async function getShelf() {
  try {
    const shelfData = await fetchWithCache(
      `shelf-full-2026-vg7vfq1`,
      () =>
        literalGraphQL(
          `query getShelfBySlug($shelfSlug: String!) {
            shelf(where: { slug: $shelfSlug }) {
              id
              slug
              title
              description
              profileId
              owner {
                id
                handle
                name
                bio
                image
                invitedByProfileId
              }
              books {
                id
                slug
                title
                subtitle
                description
                isbn10
                isbn13
                language
                pageCount
                publishedDate
                publisher
                cover
                authors {
                  id
                  name
                }
                gradientColors
              }
            }
          }`,
          { shelfSlug: "2026-vg7vfq1" },
          true
        )
    );

    const shelf = shelfData.data?.shelf;
    if (!shelf?.books) return [];

    // Fetch all book details in parallel
    const booksWithDetails = await Promise.all(
      shelf.books.map(async (book: any) => {
        try {
          const details = await fetchBookDetails(book.id);
          const isCurrentlyReading = currentBooks.some(
            (currentBook: any) => currentBook.id === book.id
          );
          const hasFinished =
            details.finished && details.finished !== "unknown";
          const status = isCurrentlyReading
            ? "IS_READING"
            : hasFinished
              ? "FINISHED"
              : "WANTS_TO_READ";

          return {
            ...book,
            ...details,
            status,
          };
        } catch (error) {
          console.error(`Error fetching details for book ${book.id}:`, error);
          const isCurrentlyReading = currentBooks.some(
            (currentBook: any) => currentBook.id === book.id
          );
          return {
            ...book,
            started: "unknown",
            finished: "unknown",
            rating: null,
            status: isCurrentlyReading ? "IS_READING" : "WANTS_TO_READ",
          };
        }
      })
    );

    return booksWithDetails;
  } catch (error) {
    console.error("Error fetching shelf from Literal.club:", error);
    return [];
  }
}

async function getBooks() {
  try {
    const finishedData = await fetchWithCache(
      `books-finished-${profileId}`,
      () =>
        literalGraphQL(
          `query booksByReadingStateAndProfile(
            $limit: Int!
            $offset: Int!
            $readingStatus: ReadingStatus!
            $profileId: String!
          ) {
            booksByReadingStateAndProfile(
              limit: $limit
              offset: $offset
              readingStatus: $readingStatus
              profileId: $profileId
            ) {
              id
              title
              cover
              authors {
                name
              }
            }
          }`,
          {
            limit: 100,
            offset: 0,
            readingStatus: "FINISHED",
            profileId,
          },
          true
        )
    );

    const finishedBooks = finishedData.data?.booksByReadingStateAndProfile || [];

    // Fetch all book details in parallel
    const bookDetailsPromises = finishedBooks.map(async (book: any) => {
      try {
        const details = await fetchBookDetails(book.id);
        return {
          ...book,
          ...details,
        };
      } catch (error) {
        console.error(`Error fetching details for book ${book.id}:`, error);
        return {
          ...book,
          started: "unknown",
          finished: "unknown",
          rating: null,
        };
      }
    });

    const booksWithDetails = await Promise.all(bookDetailsPromises);
    const books = new Map<number, any>();

    for (const b of booksWithDetails) {
      if (b.finished != null && b.finished !== "unknown") {
        const year = moment(b.finished).year();
        let read = books.get(year);
        if (read == null) {
          read = [b];
          books.set(year, read);
        } else {
          read.push(b);
        }
      } else {
        const year = 2023;
        let read = books.get(year);
        if (read == null) {
          read = [b];
          books.set(year, read);
        } else {
          read.push(b);
        }
      }
    }

    return books;
  } catch (error) {
    console.error("Error fetching finished books from Literal.club:", error);
    return new Map<number, any>();
  }
}

const [shelf, books] = await Promise.all([getShelf(), getBooks()]);
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
	</head>
	<body>
		<Header />
		<main>
			<div
				class="container flex flex-col md:flex-row gap-[32px] md:gap-[64px] py-[32px] md:py-[64px] md:!max-w-[992px]"
				style="--grid-placement: 12; --gutter: 43px;"
				x-data="{
					list: true,
					floatingCover: {
						show: false,
						x: 0,
						y: 0,
						src: '',
						title: ''
					}
				}"
			>
				<div
					class="flex flex-col gap-[32px] w-full relative"
					@mousemove="floatingCover.x = $event.clientX + 20; floatingCover.y = $event.clientY + 20"
					@mouseleave="floatingCover.show = false; floatingCover.src = ''; floatingCover.title = ''; console.log('floating cover is', typeof(floatingCover.src))"
				>
					<!-- Floating book cover -->
					<div
						x-show="floatingCover.show && floatingCover.src"
						x-transition.opacity
						class="fixed pointer-events-none z-50 w-[200px] aspect-[1/1.5] overflow-hidden shadow-lg"
						:class="{ 'opacity-100': floatingCover.show && floatingCover.src, 'opacity-0': !floatingCover.show || !floatingCover.src }"
						x-bind:style="`left: ${floatingCover.x}px; top: ${floatingCover.y}px;`"
					>
						<div x-show="floatingCover.src" class="relative w-full h-full">
							<img
								x-bind:src="floatingCover.src"
								x-bind:alt="floatingCover.title"
								class="w-full h-full object-cover"
							/>
						</div>
					</div>

					<div class="flex flex-col gap-[20px]">
						<h2 class="h2 col-span-full mb-[24px]">2026 Reading List <span class="text-[20px] opacity-75">({shelf?.length})</span></h2>
						<ol
							class="post-list flow max-md:mx-[-16px]"
							style="--flow-space: 0;"
						>
							{
								shelf?.map((book: any, i: number) => (
									<BookItem
										title={book.title}
										author={book.authors[0]["name"]}
										rating={book.rating}
										cover={book.cover}
										started={book.started}
										finished={book.finished}
										status={book.status}
										showStrikethrough=true
									/>
								))
							}
						</ol>
					</div>

					{
						[...books].map((year, i) => (
							<ul class="col-span-full">
								<li>
									{i === 0 ? (
										<div class="flex flex-col mt-[var(--space-xs)]">
											<h2 class="h2">
												Books read in {year[0]}{" "}
												<span class="text-[20px] opacity-75">
													({year[1].length})
												</span>
											</h2>
											<ol
												class="post-list flow max-md:mx-[-16px] gap-y-[var(--space-m)] mt-[var(--space-m)]"
												style="--flow-space: 0;"
											>
												{[...books][i][1].map((book: any) => (
													<BookItem
														title={book.title}
														author={book.authors[0]["name"]}
														rating={book.rating}
														cover={book.cover}
													/>
												))}
											</ol>
										</div>
									) : (
										<details class="flex flex-col">
											<summary class="h2 cursor-pointer list-none">
												<span>
													Books read in {year[0]}{" "}
													<span class="text-[20px] opacity-75">
														({year[1].length})
													</span>
												</span>
											</summary>
											<ol
												class="post-list flow max-md:mx-[-16px] mt-[var(--space-m)]"
												style="--flow-space: 0;"
											>
												{[...books][i][1].map((book: any, index: number) => (
													<BookItem
														key={index}
														title={book.title}
														author={book.authors[0]["name"]}
														rating={book.rating}
														cover={book.cover}
													/>
												))}
											</ol>
										</details>
									)}
								</li>
							</ul>
						))
					}
					<ul class="col-span-full">
						<li>
							<div
								class="flex flex-col gap-y-[var(--space-s)] md:gap-y-[var(--space-m)]"
							>
								<h2 class="h2">
									Backlog{" "}
								</h2>
								<ol
									class="post-list flow max-md:mx-[-16px]"
									style="--flow-space: 0;"
								>
									{
										toReadBooks.map((book) => (
											<BookItem
												title={book.title}
												author={book.authors[0]["name"]}
											/>
										))
									}
								</ol>
							</div>
						</li>
					</ul>
				</div>
			</div>
		</main>

		<PatternBanner fill="rgba(0, 0, 0, 0.64)" />
	</body>
</html>
