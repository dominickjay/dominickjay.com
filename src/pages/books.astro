---
// Astro.response.headers.set("Cache-Control", "p currently ublic, max-age=300, s-maxage=86400");
import BaseHead from "../components/BaseHead.astro";
import Header from "../components/Header.astro";
import PatternBanner from "../components/Pattern-Banner.astro";
import BookItem from "../components/BookItem.astro";
import { SITE_TITLE, SITE_DESCRIPTION } from "../consts";
import moment from "moment";

// Simple in-memory cache to avoid rate limiting during development
const cache = new Map<string, { data: any; expires: number }>();
const CACHE_TTL = 30000; // 30 seconds

let allBooks = [];
let backlog = [];
let currentlyReading = [];
let currentList = [];
let currentListCount = 0;
let currentListBooks = [];

function getCached(key: string): any | null {
	const cached = cache.get(key);
	if (cached && cached.expires > Date.now()) {
		return cached.data;
	}
	cache.delete(key);
	return null;
}

function setCached(key: string, data: any): void {
	cache.set(key, { data, expires: Date.now() + CACHE_TTL });
}

const hardcoverToken = (import.meta.env.hardcoverToken ?? "").trim();

console.log("ðŸ”§ Config:", {
	hasToken: !!hardcoverToken,
	tokenLength: hardcoverToken.length,
});

if (!hardcoverToken) {
	console.warn(
		"Warning: hardcoverToken environment variable is not set. " +
			"Authenticated requests will fail. " +
			"Get your token from https://hardcover.app/account/api",
	);
}

// Helper function to make GraphQL requests
async function hardcoverGraphQL(
	query: string,
	variables: any,
	useAuth = false,
) {
	if (useAuth && !hardcoverToken) {
		throw new Error(
			"Hardcover token is required for authenticated requests. " +
				"Please set the hardcoverToken environment variable. " +
				"Get your token from https://hardcover.app/account/api",
		);
	}

	// Create cache key from query and variables
	const cacheKey = JSON.stringify({ query, variables });
	const cached = getCached(cacheKey);
	if (cached) {
		console.log("ðŸ’¾ Using cached response for query");
		return cached;
	}

	const headers: Record<string, string> = {
		"Content-Type": "application/json",
		"User-Agent": "dominickjay.com/1.0",
	};

	if (useAuth) {
		// Use Bearer prefix for JWT tokens (standard for Hasura/GraphQL APIs)
		headers["authorization"] = hardcoverToken.startsWith("Bearer ")
			? hardcoverToken
			: `Bearer ${hardcoverToken}`;
	}

	const response = await fetch("https://api.hardcover.app/v1/graphql", {
		method: "POST",
		headers,
		body: JSON.stringify({ query, variables }),
	});

	console.log("ðŸŒ GraphQL Response status:", response.status);

	if (!response.ok) {
		const errorText = await response.text();
		console.error("ðŸŒ GraphQL Error response:", errorText);

		// If rate limited, wait a bit and suggest using cache
		if (response.status === 429) {
			console.warn(
				"âš ï¸ Rate limited! Consider waiting 60 seconds or using cached responses.",
			);
		}

		throw new Error(
			`HTTP error! status: ${response.status}, message: ${errorText}`,
		);
	}

	const json = await response.json();
	setCached(cacheKey, json);
	// console.log("ðŸŒ GraphQL Response data:", JSON.stringify(json, null, 2));
	return json;
}

// Fetch list book IDs first to filter them out
let listBookIds = new Set();
let listBooksCount = 0;
let listBooks: any[] = [];

// Fetch to-read, currently reading books, and list info in parallel
let currentBooks: any[] = [];
let toReadBooks: any[] = [];
let sortedYears: any[] = [];

try {
	const [toReadData, currentDataAndList, listInfo] = await Promise.all([
		hardcoverGraphQL(
			`query getUserBooks($statusId: Int!) {
        me {
          user_books(where: { status_id: { _eq: $statusId } }) {
            book {
              id
              title
              image {
                url
              }
              contributions {
                author {
                  name
                }
              }
            }
          }
        }
      }`,
			{
				statusId: 1,
			},
			true,
		),
		hardcoverGraphQL(
			`query getCurrentReadingAndList {
        me {
          user_books(where: { status_id: { _eq: 2 } }) {
            rating
            book {
              id
              title
              contributions {
                author {
                  name
                }
              }
            }
          }
          lists(where: {id: {_eq: 328925}}) {
            id
            name
            books_count
            list_books {
              book {
              	id
                title
                contributions {
                  author {
                    name
                  }
                }
                user_books(
                  where: {user_id: {_eq: 28090}}
                  limit: 1
                  order_by: {updated_at: desc}
                ) {
                  user_book_status {
                    status
                    slug
                  }
                  user_book_reads(limit: 1, order_by: {finished_at: desc_nulls_first}) {
                    started_at
                    finished_at
                  }
                }
              }
            }
          }
        }
      }`,
			{},
			true,
		),
		hardcoverGraphQL(
			`query getBooksByYear {
	      me {
	        # We fetch from user_books directly to get all your reading history
	        user_books(where: {user_book_status: {slug: {_eq: "read"}}}) {
	          book {
							id
              title
              contributions {
                author {
                  name
                }
              }
	          }
	          user_book_reads {
	            finished_at
	          }
	        }
	      }
			    }`,
			{},
			true,
		),
	]);

	allBooks = listInfo.data.me[0].user_books || [];
	backlog = toReadData.data.me[0].user_books || [];
	currentlyReading = currentDataAndList.data.me[0].user_books || [];
	currentList = currentDataAndList.data.me[0].lists[0] || [];
	currentListCount = currentList.books_count;
	currentListBooks = currentList.list_books;
} catch (error) {
	console.error(error);
	// Expected output: ReferenceError: nonExistentFunction is not defined
	// (Note: the exact output may be browser-dependent)
}
console.clear();
// console.log(currentListBooks);
// console.log("-- backlog ---");
// console.log(currentListBooks[6].book.user_books[0].user_book_status.slug);
// currentListBooks.find(
// 	(book) =>
// 		book.book.user_books[0].user_book_status.slug === "currently-reading",
// ),
const readCount = currentListBooks.filter(
	(book) => book.book.user_books[0].user_book_status.slug == "read",
);

let booksByYear = allBooks.reduce((acc, entry) => {
	const title = entry.book.title;

	entry.user_book_reads.forEach((read) => {
		if (read.finished_at) {
			const year = new Date(read.finished_at).getFullYear();
			if (!acc[year]) acc[year] = [];

			// Prevent duplicate titles in the same year
			if (!acc[year].find((b) => b.title === title)) {
				acc[year].push({
					id: entry.book.id,
					title,
					author: entry.book.contributions[0].author.name,
					finished: entry.user_book_reads[0].finished_at,
				});
				// console.log(acc[year]);
			}
		}
	});
	return acc;
}, {});

// Define it here so it's scoped correctly for the template
sortedYears = Object.keys(booksByYear).sort((a, b) => b - a);
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title="Reading List" description={SITE_DESCRIPTION} />
	</head>
	<body>
		<Header />
		<main>
			<div
				class="container flex flex-col md:flex-row gap-[32px] md:gap-[64px] py-[32px] md:py-[64px] md:!max-w-[992px]"
				style="--grid-placement: 12; --gutter: 43px;"
				x-data="{
					list: true,
					floatingCover: {
						show: false,
						x: 0,
						y: 0,
						src: '',
						title: ''
					}
				}"
			>
				<div
					class="flex flex-col gap-[32px] w-full relative"
					@mousemove="floatingCover.x = $event.clientX + 20; floatingCover.y = $event.clientY + 20"
					@mouseleave="floatingCover.show = false; floatingCover.src = ''; floatingCover.title = ''; console.log('floating cover is', typeof(floatingCover.src))"
				>
					<!-- Floating book cover -->
					<div
						x-show="floatingCover.show && floatingCover.src"
						x-transition.opacity
						class="fixed pointer-events-none z-50 w-[200px] aspect-[1/1.5] overflow-hidden shadow-lg"
						:class="{ 'opacity-100': floatingCover.show && floatingCover.src, 'opacity-0': !floatingCover.show || !floatingCover.src }"
						x-bind:style="`left: ${floatingCover.x}px; top: ${floatingCover.y}px;`"
					>
						<div x-show="floatingCover.src" class="relative w-full h-full">
							<img
								x-bind:src="floatingCover.src"
								x-bind:alt="floatingCover.title"
								class="w-full h-full object-cover"
							/>
						</div>
					</div>

					<div class="flex flex-col gap-[20px]">
						<h2 class="h2 col-span-full mb-[24px]">
							2026 Reading List <span class="text-[20px] opacity-75"
								>({readCount.length} / {currentListBooks?.length || 0})</span
							>
						</h2>
						<ol
							class="post-list flow max-md:mx-[-16px]"
							style="--flow-space: 0;"
						>
							{
								currentListBooks?.map(
									(book) =>
										book.book.user_books[0].user_book_status.slug ==
											"currently-reading" && (
											<BookItem
												title={book.book.title}
												author={
													book.book.contributions[0]?.author.name ||
													"Unknown Author"
												}
												rating={book.book.rating}
												cover={book.book.cover}
												started={
													book.book.user_books[0]?.user_book_reads[0]
														?.started_at
												}
												finished={
													book.book.user_books[0]?.user_book_reads[0]
														?.finished_at
												}
												status={book.book.user_books[0].user_book_status.slug}
												showStrikethrough={
													book.book.user_books[0].user_book_status.slug ===
													"read"
														? true
														: false
												}
											/>
										),
								)
							}
							{
								currentListBooks?.map(
									(book) =>
										book.book.user_books[0].user_book_status.slug !=
											"currently-reading" && (
											<BookItem
												title={book.book.title}
												author={
													book.book.contributions[0]?.author.name ||
													"Unknown Author"
												}
												rating={book.book.rating}
												cover={book.book.cover}
												started={
													book.book.user_books[0]?.user_book_reads[0]
														?.started_at
												}
												finished={
													book.book.user_books[0]?.user_book_reads[0]
														?.finished_at
												}
												status={book.book.user_books[0].user_book_status.slug}
												showStrikethrough={
													book.book.user_books[0].user_book_status.slug ===
													"read"
														? true
														: false
												}
											/>
										),
								)
							}
						</ol>
					</div>

					{
						sortedYears.map((year, i) => (
							<ul class="col-span-full">
								<li>
									{i === 0 ? (
										<div class="flex flex-col mt-[var(--space-xs)]">
											<h2 class="h2">
												Books read in {year}{" "}
												<span class="text-[20px] opacity-75">
													({year[1].length})
												</span>
											</h2>
											<ol
												class="post-list flow max-md:mx-[-16px] gap-y-[var(--space-m)] mt-[var(--space-m)]"
												style="--flow-space: 0;"
											>
												{booksByYear[year].map((book) => (
													<BookItem title={book.title} author={book.author} />
												))}
											</ol>
										</div>
									) : (
										<details class="flex flex-col">
											<summary class="h2 cursor-pointer list-none">
												<span>
													Books read in {year}{" "}
													<span class="text-[20px] opacity-75">
														({booksByYear[year].length})
													</span>
												</span>
											</summary>
											<ol
												class="post-list flow max-md:mx-[-16px] gap-y-[var(--space-m)] mt-[var(--space-m)]"
												style="--flow-space: 0;"
											>
												{booksByYear[year].map((book) => (
													<BookItem title={book.title} author={book.author} />
												))}
											</ol>
										</details>
									)}
								</li>
							</ul>
						))
					}
					<ul class="col-span-full">
						<li>
							<div
								class="flex flex-col gap-y-[var(--space-s)] md:gap-y-[var(--space-m)]"
							>
								<h2 class="h2">
									Backlog{" "}
								</h2>
								<ol
									class="post-list flow max-md:mx-[-16px]"
									style="--flow-space: 0;"
								>
									{
										backlog.map((book) => (
											<BookItem
												key={book.book.id}
												title={book.book.title}
												author={
													book.book.contributions[0]?.author.name ||
													"Unknown Author"
												}
												rating={book.book.rating}
												cover={book.book.cover}
											/>
										))
									}
								</ol>
							</div>
						</li>
					</ul>
				</div>
			</div>
		</main>

		<PatternBanner fill="rgba(0, 0, 0, 0.64)" />
	</body>
</html>
