---
// Astro.response.headers.set("Cache-Control", "p currently ublic, max-age=300, s-maxage=86400");
import BaseHead from "../components/BaseHead.astro";
import Header from "../components/Header.astro";
import PatternBanner from "../components/Pattern-Banner.astro";
import BookItem from "../components/BookItem.astro";
import { SITE_TITLE, SITE_DESCRIPTION } from "../consts";
import moment from "moment";
import FeatureListItem from "../components/FeatureListItem.astro";

// Simple in-memory cache to avoid rate limiting during development
const cache = new Map<string, { data: any; expires: number }>();
const CACHE_TTL = 30000; // 30 seconds

let allBooks = [];
let backlog = [];
let currentlyReading = [];
let currentList = [];
let currentListCount = 0;
let currentListBooks = [];

function getCached(key: string): any | null {
  const cached = cache.get(key);
  if (cached && cached.expires > Date.now()) {
    return cached.data;
  }
  cache.delete(key);
  return null;
}

function setCached(key: string, data: any): void {
  cache.set(key, { data, expires: Date.now() + CACHE_TTL });
}

const hardcoverToken = (import.meta.env.hardcoverToken ?? "").trim();

console.log("ðŸ”§ Config:", {
  hasToken: !!hardcoverToken,
  tokenLength: hardcoverToken.length,
});

if (!hardcoverToken) {
  console.warn(
    "Warning: hardcoverToken environment variable is not set. " +
      "Authenticated requests will fail. " +
      "Get your token from https://hardcover.app/account/api",
  );
}

// Helper function to make GraphQL requests
async function hardcoverGraphQL(
  query: string,
  variables: any,
  useAuth = false,
) {
  if (useAuth && !hardcoverToken) {
    throw new Error(
      "Hardcover token is required for authenticated requests. " +
        "Please set the hardcoverToken environment variable. " +
        "Get your token from https://hardcover.app/account/api",
    );
  }

  // Create cache key from query and variables
  const cacheKey = JSON.stringify({ query, variables });
  const cached = getCached(cacheKey);
  if (cached) {
    console.log("ðŸ’¾ Using cached response for query");
    return cached;
  }

  const headers: Record<string, string> = {
    "Content-Type": "application/json",
    "User-Agent": "dominickjay.com/1.0",
  };

  if (useAuth) {
    // Use Bearer prefix for JWT tokens (standard for Hasura/GraphQL APIs)
    headers["authorization"] = hardcoverToken.startsWith("Bearer ")
      ? hardcoverToken
      : `Bearer ${hardcoverToken}`;
  }

  const response = await fetch("https://api.hardcover.app/v1/graphql", {
    method: "POST",
    headers,
    body: JSON.stringify({ query, variables }),
  });

  console.log("ðŸŒ GraphQL Response status:", response.status);

  if (!response.ok) {
    const errorText = await response.text();
    console.error("ðŸŒ GraphQL Error response:", errorText);

    // If rate limited, wait a bit and suggest using cache
    if (response.status === 429) {
      console.warn(
        "âš ï¸ Rate limited! Consider waiting 60 seconds or using cached responses.",
      );
    }

    throw new Error(
      `HTTP error! status: ${response.status}, message: ${errorText}`,
    );
  }

  const json = await response.json();
  setCached(cacheKey, json);
  // console.log("ðŸŒ GraphQL Response data:", JSON.stringify(json, null, 2));
  return json;
}

// Fetch list book IDs first to filter them out
let listBookIds = new Set();
let listBooksCount = 0;
let listBooks: any[] = [];

// Fetch to-read, currently reading books, and list info in parallel
let currentBooks: any[] = [];
let toReadBooks: any[] = [];
let sortedYears: any[] = [];

try {
  const [toReadData, currentDataAndList, listInfo] = await Promise.all([
    hardcoverGraphQL(
      `query getUserBooks($statusId: Int!) {
        me {
          user_books(where: { status_id: { _eq: $statusId } }) {
            book {
              id
              title
              image {
                url
              }
              contributions {
                author {
                  name
                }
              }
            }
          }
        }
      }`,
      {
        statusId: 1,
      },
      true,
    ),
    hardcoverGraphQL(
      `query getCurrentReadingAndList {
        me {
          user_books(where: { status_id: { _eq: 2 } }) {
            rating
            book {
              id
              title
              contributions {
                author {
                  name
                }
              }
            }
          }
          lists(where: {id: {_eq: 328925}}) {
            id
            name
            books_count
            list_books {
              book {
              	id
                title
                contributions {
                  author {
                    name
                  }
                }
                user_books(
                  where: {user_id: {_eq: 28090}}
                  limit: 1
                  order_by: {updated_at: desc}
                ) {
                  user_book_status {
                    status
                    slug
                  }
                  user_book_reads(limit: 1, order_by: {finished_at: desc_nulls_first}) {
                    started_at
                    finished_at
                  }
                }
              }
            }
          }
        }
      }`,
      {},
      true,
    ),
    hardcoverGraphQL(
      `query getBooksByYear {
	      me {
	        # We fetch from user_books directly to get all your reading history
	        user_books(where: {user_book_status: {slug: {_eq: "read"}}}) {
	          book {
							id
              title
              contributions {
                author {
                  name
                }
              }
	          }
	          user_book_reads {
	            finished_at
	          }
	        }
	      }
			    }`,
      {},
      true,
    ),
  ]);

  allBooks = listInfo.data.me[0].user_books || [];
  backlog = toReadData.data.me[0].user_books || [];
  currentlyReading = currentDataAndList.data.me[0].user_books || [];
  currentList = currentDataAndList.data.me[0].lists[0] || [];
  currentListCount = currentList.books_count;
  currentListBooks = currentList.list_books;
} catch (error) {
  console.error(error);
  // Expected output: ReferenceError: nonExistentFunction is not defined
  // (Note: the exact output may be browser-dependent)
}
console.clear();
// console.log(currentListBooks);
// console.log("-- backlog ---");
// console.log(currentListBooks[6].book.user_books[0].user_book_status.slug);
// currentListBooks.find(
// 	(book) =>
// 		book.book.user_books[0].user_book_status.slug === "currently-reading",
// ),
const readCount = currentListBooks.filter(
  (book) => book.book.user_books[0].user_book_status.slug == "read",
);

let booksByYear = allBooks.reduce((acc, entry) => {
  const title = entry.book.title;

  entry.user_book_reads.forEach((read) => {
    if (read.finished_at) {
      const year = new Date(read.finished_at).getFullYear();
      if (!acc[year]) acc[year] = [];

      // Prevent duplicate titles in the same year
      if (!acc[year].find((b) => b.title === title)) {
        acc[year].push({
          id: entry.book.id,
          title,
          author: entry.book.contributions[0].author.name,
          finished: entry.user_book_reads[0].finished_at,
        });
        // console.log(acc[year]);
      }
    }
  });
  return acc;
}, {});

// Define it here so it's scoped correctly for the template
sortedYears = Object.keys(booksByYear).sort((a, b) => b - a);

const totalReadCount = allBooks.filter((entry) =>
  entry.user_book_reads?.some((read) => read.finished_at),
).length;
---

<!doctype html>
<html lang="en">
  <head>
    <BaseHead title="Reading List" description={SITE_DESCRIPTION} />
  </head>
  <body>
    <div id="cur"></div>
    <Header />
    <main>
      <div
        class="container flex flex-col md:flex-row gap-[32px] md:gap-[64px] py-[32px] md:py-[64px] md:!max-w-[992px]"
        style="--grid-placement: 12; --gutter: 43px;"
      >
        <div class="flex flex-col gap-[32px] w-full relative">
          <div class="stage-meta">
            <div class="progress-ring-wrap">
              <svg width="64" height="64" viewBox="0 0 64 64">
                <circle class="progress-ring-bg" cx="32" cy="32" r="26"
                ></circle>
                <circle
                  class="progress-ring-fill"
                  id="progressRing"
                  cx="32"
                  cy="32"
                  r="26"></circle>
              </svg>
              <div class="progress-ring-text">
                <strong>{readCount.length}</strong>
                <span>/ {currentListBooks.length}</span>
              </div>
            </div>
            <div class="stage-stats">
              <div class="stage-stat-item">
                <div class="stage-stat-val" id="cntRead">
                  {readCount.length}
                </div>
                <div class="stage-stat-label">Read in 2026</div>
              </div>
              <div class="stage-stat-item">
                <div class="stage-stat-val">2</div>
                <div class="stage-stat-label">Currently reading</div>
              </div>
              <div class="stage-stat-item">
                <div class="stage-stat-val" id="cntBacklog">
                  {backlog.length}
                </div>
                <div class="stage-stat-label">In backlog</div>
              </div>
              <div class="stage-stat-item">
                <div class="stage-stat-val" id="cntTotal">{totalReadCount}</div>
                <div class="stage-stat-label">All time read</div>
              </div>
            </div>
          </div>
          <div class="flex flex-col gap-[20px]">
            <h2 class="h2 col-span-full mb-[24px]">Currently Reading</h2>
            <ol class="post-list feature-list flow" style="--flow-space: 0;">
              {
                currentListBooks?.map(
                  (book) =>
                    book.book.user_books[0].user_book_status.slug ==
                      "currently-reading" && (
                      <BookItem
                        title={book.book.title}
                        author={
                          book.book.contributions[0]?.author.name ||
                          "Unknown Author"
                        }
                        rating={book.book.rating}
                        cover={book.book.cover}
                        started={
                          book.book.user_books[0]?.user_book_reads[0]
                            ?.started_at
                        }
                        finished={
                          book.book.user_books[0]?.user_book_reads[0]
                            ?.finished_at
                        }
                        status={book.book.user_books[0].user_book_status.slug}
                        showStrikethrough={
                          book.book.user_books[0].user_book_status.slug ===
                          "read"
                            ? true
                            : false
                        }
                      />
                    ),
                )
              }
            </ol>
          </div>

          <div class="flex flex-col gap-[20px]">
            <h2 class="h2 col-span-full mb-[24px]">
              2026 Reading List <span class="text-[20px] opacity-75"
                >({readCount.length} / {currentListBooks?.length || 0})</span
              >
            </h2>
            <ol class="post-list feature-list flow" style="--flow-space: 0;">
              {
                currentListBooks
                  ?.filter(
                    (book) =>
                      book.book.user_books[0].user_book_status.slug !==
                        "currently-reading" &&
                      book.book.user_books[0].user_book_status.slug !== "read",
                  )
                  ?.map((book, i) => (
                    <BookItem
                      i={String(i + 1).padStart(2, "0")}
                      title={book.book.title}
                      author={
                        book.book.contributions[0]?.author.name ||
                        "Unknown Author"
                      }
                      rating={book.book.rating}
                      cover={book.book.cover}
                      queued={
                        book.book.user_books[0].user_book_status.slug === "read"
                          ? true
                          : false
                      }
                      started={
                        book.book.user_books[0]?.user_book_reads[0]?.started_at
                      }
                      finished={
                        book.book.user_books[0]?.user_book_reads[0]?.finished_at
                      }
                      status={book.book.user_books[0].user_book_status.slug}
                      showStrikethrough={
                        book.book.user_books[0].user_book_status.slug === "read"
                          ? true
                          : false
                      }
                    />
                  ))
              }
            </ol>
          </div>

          {
            sortedYears.map((year, i) => (
              <ul class="col-span-full">
                <li>
                  {i === 0 ? (
                    <div class="flex flex-col mt-[var(--space-xs)]">
                      <h2 class="h2">
                        Books read in {year}{" "}
                        <span class="text-[20px] opacity-75">
                          ({booksByYear[year].length})
                        </span>
                      </h2>
                      <ol
                        class="post-list feature-list flow max-md:mx-[-16px] mt-[var(--space-m)]"
                        style="--flow-space: 0;"
                      >
                        {booksByYear[year].map((book, i) => (
                          <BookItem
                            i={String(i + 1).padStart(2, "0")}
                            title={book.title}
                            author={book.author}
                          />
                        ))}
                      </ol>
                    </div>
                  ) : (
                    <details class="flex flex-col">
                      <summary class="h2 cursor-pointer list-none">
                        <span>
                          Books read in {year}{" "}
                          <span class="text-[20px] opacity-75">
                            ({booksByYear[year].length})
                          </span>
                        </span>
                      </summary>
                      <ol
                        class="post-list feature-list flow max-md:mx-[-16px] gap-y-[var(--space-m)] mt-[var(--space-m)]"
                        style="--flow-space: 0;"
                      >
                        {booksByYear[year].map((book, i) => (
                          <BookItem
                            i={String(i + 1).padStart(2, "0")}
                            title={book.title}
                            author={book.author}
                          />
                        ))}
                      </ol>
                    </details>
                  )}
                </li>
              </ul>
            ))
          }
          <ul class="col-span-full">
            <li>
              <div
                class="flex flex-col gap-y-[var(--space-s)] md:gap-y-[var(--space-m)]"
              >
                <h2 class="h2">
                  Backlog{" "}
                </h2>
                <ol
                  class="post-list feature-list flow max-md:mx-[-16px]"
                  style="--flow-space: 0;"
                >
                  {
                    backlog.map((book, i) => (
                      <BookItem
                        i={String(i + 1).padStart(2, "0")}
                        key={book.book.id}
                        title={book.book.title}
                        author={
                          book.book.contributions[0]?.author.name ||
                          "Unknown Author"
                        }
                        rating={book.book.rating}
                        cover={book.book.cover}
                      />
                    ))
                  }
                </ol>
              </div>
            </li>
          </ul>
        </div>
      </div>
    </main>

    <PatternBanner fill="rgba(0, 0, 0, 0.64)" />
  </body><script is:inline>
    document.addEventListener("mousemove", (e) => {
      const cur = document.getElementById("cur");
      if (cur) {
        cur.style.left = e.clientX + "px";
        cur.style.top = e.clientY + "px";
      }
    });
    document.querySelectorAll(".prose, .body, .intro").forEach((el) => {
      el.addEventListener("mouseenter", () =>
        document.body.classList.add("cur-sm"),
      );
      el.addEventListener("mouseleave", () =>
        document.body.classList.remove("cur-sm"),
      );
    });
    document
      .querySelectorAll("a:not([class]), button, .post-item")
      .forEach((el) => {
        el.addEventListener(
          "mouseenter",
          () => document.body.classList.remove("cur-sm"),
          document.body.classList.add("cur-lg"),
        );
        el.addEventListener(
          "mouseleave",
          () => document.body.classList.add("cur-sm"),
          document.body.classList.remove("cur-lg"),
        );
      });
  </script>
</html>
