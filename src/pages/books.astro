---
import BaseHead from "../components/BaseHead.astro";
import Header from "../components/Header.astro";
import FormattedDate from "../components/FormattedDate.astro";
import PatternBanner from "../components/Pattern-Banner.astro";
import Footer from "../components/Footer.astro";
import { Image } from "astro:assets";
import { SITE_TITLE, SITE_DESCRIPTION, SITE_TAGLINE } from "../consts";
import moment from "moment";

let currentBooks = [];
let finishedBooks = [];
let readBooks = [];
let toReadBooks = [];

// Fetch shelf book IDs first to filter them out
let shelfBookIds = new Set();
try {
	const shelfResponse = await fetch("https://literal.club/graphql/", {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({
			query: `query getShelfBySlug($shelfSlug: String!) {
				shelf(where: { slug: $shelfSlug }) {
					books {
						id
					}
				}
			}`,
			variables: {
				shelfSlug: "2026-vg7vfq1",
			},
		}),
	});

	if (shelfResponse.ok) {
		const shelfData = await shelfResponse.json();
		const shelfBooks = shelfData.data?.shelf?.books || [];
		shelfBookIds = new Set(shelfBooks.map((book: any) => book.id));
	}
} catch (error) {
	console.error("Error fetching shelf for filtering:", error);
}

try {
	const response = await fetch("https://literal.club/graphql/", {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({
			query: `query booksByReadingStateAndProfile(
					$limit: Int!
					$offset: Int!
					$readingStatus: ReadingStatus!
					$profileId: String!
				) {
					booksByReadingStateAndProfile(
							limit: $limit
							offset: $offset
							readingStatus: $readingStatus
							profileId: $profileId
					)
					{ id title cover authors {
							name
					} } }`,
			variables: {
				limit: 100,
				offset: 0,
				readingStatus: "WANTS_TO_READ",
				profileId: import.meta.env.profileId,
			},
		}),
	});

	if (!response.ok) {
		throw new Error(`HTTP error! status: ${response.status}`);
	}

	const data = await response.json();
	const allToReadBooks = data.data?.booksByReadingStateAndProfile || [];
	toReadBooks = allToReadBooks.filter(
		(book: any) => !shelfBookIds.has(book.id),
	);
} catch (error) {
	console.error("Error fetching to-read books from Literal.club:", error);
	toReadBooks = [];
}

try {
	const response = await fetch("https://literal.club/graphql/", {
		method: "POST",
		headers: { "Content-Type": "application/json" },
		body: JSON.stringify({
			query: `query booksByReadingStateAndProfile(
					$limit: Int!
					$offset: Int!
					$readingStatus: ReadingStatus!
					$profileId: String!
				) {
					booksByReadingStateAndProfile(
							limit: $limit
							offset: $offset
							readingStatus: $readingStatus
							profileId: $profileId
					)
					{ id title cover authors {
							name
					} } }`,
			variables: {
				limit: 100,
				offset: 0,
				readingStatus: "IS_READING",
				profileId: import.meta.env.profileId,
			},
		}),
	});

	if (!response.ok) {
		throw new Error(`HTTP error! status: ${response.status}`);
	}

	const data = await response.json();
	currentBooks = data.data?.booksByReadingStateAndProfile || [];
} catch (error) {
	console.error(
		"Error fetching currently reading books from Literal.club:",
		error,
	);
	currentBooks = [];
}

async function getShelf() {
	try {
		const response = await fetch("https://literal.club/graphql/", {
			method: "POST",
			body: JSON.stringify({
				query: `query getShelfBySlug($shelfSlug: String!) {
					shelf(where: { slug: $shelfSlug }) {
						id
						slug
						title
						description
						profileId
						owner {
							id
							handle
							name
							bio
							image
							invitedByProfileId
						}
						books {
							id
							slug
							title
							subtitle
							description
							isbn10
							isbn13
							language
							pageCount
							publishedDate
							publisher
							cover
							authors {
								id
								name
							}
							gradientColors
						}
					}
				}`,
				variables: {
					shelfSlug: "2026-vg7vfq1",
				},
			}),
			headers: {
				"Content-Type": "application/json",
				authorization: import.meta.env.literalToken ?? "",
			},
		});

		if (!response.ok) {
			throw new Error(`HTTP error! status: ${response.status}`);
		}

		const data = (await response.json()) as any;
		const shelf = data.data?.shelf;
		const booksWithDetails = [];

		for (const book of shelf?.books || []) {
			try {
				const datesResponse = await fetch("https://literal.club/graphql/", {
					method: "POST",
					body: JSON.stringify({
						query: `query getReadDates($bookId: String!, $profileId: String!) {
							getReadDates(bookId: $bookId, profileId: $profileId) {
								started
								finished
							}
						}`,
						variables: {
							bookId: book.id,
							profileId: import.meta.env.profileId,
						},
					}),
					headers: {
						"Content-Type": "application/json",
						authorization: import.meta.env.literalToken ?? "",
					},
				});

				if (!datesResponse.ok) {
					throw new Error(`HTTP error! status: ${datesResponse.status}`);
				}

				const dates = (await datesResponse.json()) as any;
				const date = dates?.data?.getReadDates?.pop();

				// Fetch rating from reviews
				let rating = null;
				try {
					const reviewResponse = await fetch("https://literal.club/graphql/", {
						method: "POST",
						body: JSON.stringify({
							query: `query getReview($bookId: String!, $profileId: String!) {
								review(bookId: $bookId, profileId: $profileId) {
									rating
								}
							}`,
							variables: {
								bookId: book.id,
								profileId: import.meta.env.profileId,
							},
						}),
						headers: {
							"Content-Type": "application/json",
							authorization: import.meta.env.literalToken ?? "",
						},
					});

					if (reviewResponse.ok) {
						const reviewData = (await reviewResponse.json()) as any;
						rating = reviewData?.data?.review?.rating ?? null;
					}
				} catch (error) {
					console.error(`Error fetching review for book ${book.id}:`, error);
				}

				const bookWithDetails = {
					...book,
					started: date?.started ? date?.started : "unknown",
					finished: date?.finished ? date?.finished : "unknown",
					rating: rating,
				};

				booksWithDetails.push(bookWithDetails);
			} catch (error) {
				console.error(`Error fetching read dates for book ${book.id}:`, error);
				const bookWithDetails = {
					...book,
					started: "unknown",
					finished: "unknown",
					rating: null,
				};
				booksWithDetails.push(bookWithDetails);
			}
		}

		const shelfWithBooks = {
			...shelf,
			books: booksWithDetails,
		};

		return booksWithDetails;
	} catch (error) {
		console.error("Error fetching shelf from Literal.club:", error);
	}
}

async function getBooks() {
	try {
		const response = await fetch("https://literal.club/graphql/", {
			method: "POST",
			body: JSON.stringify({
				query: `query booksByReadingStateAndProfile(
				$limit: Int!
				$offset: Int!
				$readingStatus: ReadingStatus!
				$profileId: String!
			) {
				booksByReadingStateAndProfile(
						limit: $limit offset: $offset readingStatus: $readingStatus profileId: $profileId) {
						id title cover authors { name } } }`,
				variables: {
					limit: 100,
					offset: 0,
					readingStatus: "FINISHED",
					profileId: import.meta.env.profileId,
				},
			}),
			headers: {
				"Content-Type": "application/json",
				authorization: import.meta.env.literalToken ?? "",
			},
		});

		if (!response.ok) {
			throw new Error(`HTTP error! status: ${response.status}`);
		}

		const data = (await response.json()) as any;
		const books = new Map<number, any>();

		for (const book of data.data?.booksByReadingStateAndProfile || []) {
			try {
				const datesResponse = await fetch("https://literal.club/graphql/", {
					method: "POST",
					body: JSON.stringify({
						query: `query getReadDates($bookId: String!, $profileId: String!) {
							getReadDates(bookId: $bookId, profileId: $profileId) {
								started
								finished
							}
						}`,
						variables: {
							bookId: book.id,
							profileId: import.meta.env.profileId,
						},
					}),
					headers: {
						"Content-Type": "application/json",
						authorization: import.meta.env.literalToken ?? "",
					},
				});

				if (!datesResponse.ok) {
					throw new Error(`HTTP error! status: ${datesResponse.status}`);
				}

				const dates = (await datesResponse.json()) as any;
				const date = dates?.data?.getReadDates?.pop();

				// Fetch rating from reviews
				let rating = null;
				try {
					const reviewResponse = await fetch("https://literal.club/graphql/", {
						method: "POST",
						body: JSON.stringify({
							query: `query getReview($bookId: String!, $profileId: String!) {
								review(bookId: $bookId, profileId: $profileId) {
									rating
								}
							}`,
							variables: {
								bookId: book.id,
								profileId: import.meta.env.profileId,
							},
						}),
						headers: {
							"Content-Type": "application/json",
							authorization: import.meta.env.literalToken ?? "",
						},
					});

					if (reviewResponse.ok) {
						const reviewData = (await reviewResponse.json()) as any;
						rating = reviewData?.data?.review?.rating ?? null;
					}
				} catch (error) {
					console.error(`Error fetching review for book ${book.id}:`, error);
				}

				const b = {
					...book,
					started: date?.started ? date?.started : "unknown",
					finished: date?.finished ? date?.finished : "unknown",
					rating: rating,
				};

				// Include all books regardless of dates
				if (b.finished != null && b.finished !== "unknown") {
					const year = moment(b.finished).year();

					let read = books.get(year);
					if (read == null) {
						read = [b];
						books.set(year, read);
					} else {
						read.push(b);
					}
				} else {
					// For books without finished dates, use a special year (e.g., 0 or current year)
					const year = 2023; // or new Date().getFullYear() if you prefer current year
					let read = books.get(year);
					if (read == null) {
						read = [b];
						books.set(year, read);
					} else {
						read.push(b);
					}
				}
			} catch (error) {
				console.error(`Error fetching read dates for book ${book.id}:`, error);
				// Continue processing other books even if one fails
				const b = {
					...book,
					started: "unknown",
					finished: "unknown",
					rating: null,
				};
				const year = 2023;
				let read = books.get(year);
				if (read == null) {
					read = [b];
					books.set(year, read);
				} else {
					read.push(b);
				}
			}
		}

		return books;
	} catch (error) {
		console.error("Error fetching finished books from Literal.club:", error);
		return new Map<number, any>();
	}
}

const shelf = await getShelf();
const books = await getBooks();
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
	</head>
	<body>
		<Header />
		<main>
			<div
				class="container flex flex-col md:flex-row gap-[32px] md:gap-[64px] py-[32px] md:py-[64px] md:!max-w-[992px]"
				style="--grid-placement: 12; --gutter: 43px;"
				x-data="{
					list: true,
					floatingCover: {
							show: false,
							x: 0,
							y: 0,
							src: '',
							title: ''
					}
				}"
			>
				<div
					class="flex flex-col gap-[32px] w-full relative"
					@mousemove="floatingCover.x = $event.clientX + 20; floatingCover.y = $event.clientY + 20"
					@mouseleave="floatingCover.show = false; floatingCover.src = ''; floatingCover.title = ''; console.log('floating cover is', typeof(floatingCover.src))"
				>
					<!-- Floating book cover -->
					<div
						x-show="floatingCover.show && floatingCover.src"
						x-transition.opacity
						class="fixed pointer-events-none z-50 w-[200px] aspect-[1/1.5] overflow-hidden shadow-lg"
						:class="{ 'opacity-100': floatingCover.show && floatingCover.src, 'opacity-0': !floatingCover.show || !floatingCover.src }"
						x-bind:style="`left: ${floatingCover.x}px; top: ${floatingCover.y}px;`"
					>
						<div x-show="floatingCover.src" class="relative w-full h-full">
							<img
								x-bind:src="floatingCover.src"
								x-bind:alt="floatingCover.title"
								class="w-full h-full object-cover"
							/>
						</div>
					</div>
					<div
						class="flex flex-col gap-[20px]"
					>
						<h2 class="h2 col-span-full mb-[24px]">2026 Reading List</h2>
						<ol class="post-list flow max-md:mx-[-16px]" style="--flow-space: 0;">
							{
								shelf.map((book, i) => (

									<li class="post-item">
										<div class="post [--block-space:var(--space-s)]">
											<div class="flex max-md:flex-col-reverse justify-between md:items-center">
												<div class={`flex max-md:flex-col items-baseline gap-[4px] ${book.finished !== "unknown" ? "line-through" : ""}`}>
													<span>{book.title}</span>
													<span class="opacity-[0.85]">by {book.authors[0]['name']}</span>
												</div>
												<div class="flex flex-row gap-x-[8px] items-center">
													{book.started != book.finished &&
														book.started !== "unknown" &&
														book.finished !== "unknown" && (
															// <p>{new Date(book.started)}</p>
															<span class="text-[16px]">
																Started:{" "}
																<FormattedDate date={new Date(book.started)} />
															</span>
															<span class="text-[16px] pt-[2px]">
														Finished:{" "}
														{book.finished !== "unknown" ? (
															<FormattedDate date={new Date(book.finished)} />
														) : (
															"Unknown date"
														)}
															</span>
														)}
													{book.rating && (
														<span class="text-[16px] pt-[2px]">
															Rating: {book.rating}/5
														</span>
													)}
												</div>
											</div>
										</div>
									</li>
								))
							}
						</ol>
					</div>
					{
						[...books].map((year, i) => (
							<ul class="col-span-full">
								<li>
									{i === 0 ? (
										<div class="flex flex-col mt-[var(--space-xs)]">
											<h2 class="h2">
												Books read in {year[0]}{" "}
												<span class="text-[20px] opacity-75">
													({year[1].length})
												</span>
											</h2>
											<ol class="post-list flow max-md:mx-[-16px] gap-y-[var(--space-m)] mt-[var(--space-m)]" style="--flow-space: 0;">
												{[...books][i][1].map((book) => (
													<li
														class="col-span-2 group post-item"
														@mouseenter={`floatingCover.show = true; floatingCover.src = ${JSON.stringify(book.cover)}; floatingCover.title = ${JSON.stringify(book.title)}`}
														@mouseleave="floatingCover.show = false; floatingCover.src = ''; floatingCover.title = ''"
													>
														<div class="post [--block-space:var(--space-s)]">
															<div class="flex max-md:flex-col-reverse justify-between md:items-center">
																<div class="flex max-md:flex-col items-baseline gap-[4px]">
																	<span>{book.title}</span>
																	<span class="opacity-[0.85]">by {book.authors[0]['name']}</span>
																</div>
																<div class="flex flex-row gap-x-[8px] items-center">
																	{book.rating && (
																		<span class="text-[16px] pt-[2px]">
																			Rating: {book.rating}/5
																		</span>
																	)}
																</div>
															</div>
														</div>
													</li>
												))}
											</ul>
										</div>
									) : (
										<details class="flex flex-col">
											<summary class="h2 cursor-pointer list-none">
												<span>
													Books read in {year[0]}{" "}
													<span class="text-[20px] opacity-75">
														({year[1].length})
													</span>
												</span>
											</summary>
											<ol class="post-list flow max-md:mx-[-16px] mt-[var(--space-m)]" style="--flow-space: 0;">
												{[...books][i][1].map((book, index) => (
												<li
													class="col-span-2 group post-item"
													@mouseenter={`floatingCover.show = true; floatingCover.src = ${JSON.stringify(book.cover)}; floatingCover.title = ${JSON.stringify(book.title)}`}
													@mouseleave="floatingCover.show = false; floatingCover.src = ''; floatingCover.title = ''"
												>
													<div class="post [--block-space:var(--space-s)]">
														<div class="flex max-md:flex-col-reverse justify-between md:items-center">
															<div class="flex max-md:flex-col items-baseline gap-[4px]">
																<span>{book.title}</span>
																<span class="opacity-[0.85]">by {book.authors[0]['name']}</span>
															</div>
															<div class="flex flex-row gap-x-[8px] items-center">
																{book.rating && (
																	<span class="text-[16px] pt-[2px]">
																		Rating: {book.rating}/5
																	</span>
																)}
															</div>
														</div>
													</div>
												</li>
												))}
											</ol>
										</details>
									)}
								</li>
							</ul>
						))
					}
					<ul class="col-span-full">
						<li>
							<div class="flex flex-col gap-y-[var(--space-s)] md:gap-y-[var(--space-m)]">
								<h2 class="h2">
									Backlog{" "}
								</h2>
								<ol class="post-list flow max-md:mx-[-16px]" style="--flow-space: 0;">
									{toReadBooks.map((book) => (
										<li
											class="col-span-2 group post-item"
											@mouseenter={`floatingCover.show = true; floatingCover.src = ${JSON.stringify(book.cover)}; floatingCover.title = ${JSON.stringify(book.title)}`}
											@mouseleave="floatingCover.show = false; floatingCover.src = ''; floatingCover.title = ''"
										>
											<div class="post [--block-space:var(--space-s)]">
												<div class="flex max-md:flex-col-reverse justify-between md:items-center">
													<div class="flex max-md:flex-col items-baseline gap-[4px] md:gap-[8px]">
														<span>{book.title}</span>
														<span class="opacity-[0.85]">by {book.authors[0]['name']}</span>
													</div>
												</div>
											</div>
										</li>
									))}
								</ol>
							</div>
						</li>
					</ul>
				</div>
			</div>
		</main>

		<PatternBanner fill="rgba(0, 0, 0, 0.64)" />
	</body>
</html>
